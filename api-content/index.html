{"posts":[{"title":"[编程语言]C++虚函数与虚函数表","content":"1. 前言 + C++中的虚函数的作用主要是****实现了多态*的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到*运行时决议****。 2. 虚函数表 对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。 C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。 虚表指针的名字也会被编译器更改，所以在多继承的情况下，类的内部可能存在多个虚表指针。通过不同的名字被编译器标识。 假设我们有这样的一个类： class Base { ​ public: ​ virtual void f() { cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; } ​ virtual void g() { cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; } ​ virtual void h() { cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; } }; 按照上面的说法，可以通过Base的实例来得到虚函数表。 下面是实际例程： typedef void(*Fun)(void); Base b; Fun pFun = NULL; cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (int*)(&amp;b) &lt;&lt; endl; cout &lt;&lt; &quot;虚函数表 — 第一个函数地址：&quot; &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl; // Invoke the first virtual function pFun = (Fun)*((int*)*(int*)(&amp;b)); pFun(); 实际运行经果如下：(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3) 虚函数表地址：0012FED4 虚函数表 — 第一个函数地址：0044F148 Base::f 通过这个示例，可以看到，我们可以通过强行把&amp;b转成int ，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下： (Fun)*((int*)*(int*)(&amp;b)+0); *// Base::f()* (Fun)*((int*)*(int*)(&amp;b)+1); *// Base::g()* (Fun)*((int*)*(int*)(&amp;b)+2); *// Base::h()* 画个图解释一下。如下所示: 注意：在上面这个图中，在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“/0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。 下面，将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。 3. 继承与虚函数表 3.1 一般继承（无虚函数覆盖） 下面，再来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系： 请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示 对于实例：Derive d; 的虚函数表如下： 我们可以看到下面几点： 虚函数按照其声明顺序放于表中。 父类的虚函数在子类的虚函数前面。 3.2 一般继承（有虚函数覆盖） 覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，有下面这样的一个继承关系。 为了看到被继承过后的效果，在这个类的设计中，只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子： 我们从表中可以看到下面几点， 覆盖的f()函数被放到了虚表中原来父类虚函数的位置。 没有被覆盖的函数依旧。 这样，我们就可以看到对于下面这样的程序， Base *b = new Derive(); b-&gt;f(); 由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。 3.3 多重继承（无虚函数覆盖） 下面，再看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数： 对于子类实例中的虚函数表，是下面这个样子： 我们可以看到： 每个父类都有自己的虚表。 子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的） 这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。 3.4 多重继承（有虚函数覆盖） 下面再来看看，如果发生虚函数覆盖的情况。下图中，我们在子类中覆盖了父类的f()函数。 下面是对于子类实例中的虚函数表的图： 可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如： Derive d; Base1 *b1 = &amp;d; Base2 *b2 = &amp;d; Base3 *b3 = &amp;d; b1-&gt;f(); //Derive::f() b2-&gt;f(); //Derive::f() b3-&gt;f(); //Derive::f() b1-&gt;g(); //Base1::g() b2-&gt;g(); //Base2::g() b3-&gt;g(); //Base3::g() 4. 安全性 水可载舟，亦可覆舟。 4.1 通过父类型的指针访问子类自己的虚函数 子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数： Base1 *b1 = new Derive(); b1-&gt;f1(); //编译出错 任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点） 4.2 访问non-public的虚函数 另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。如： class Base { private: virtual void f() { cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; }; class Derive : public Base{ }; typedef void(*Fun)(void); void main() { Derive d; Fun pFun = (Fun)*((int*)*(int*)(&amp;d)+0); pFun(); } 5. 结束语 C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。 6. 附录 6.1 VC中查看虚函数表 以在VC的IDE环境中的Debug状态下展开类的实例就可以看到虚函数表了（并不是很完整的） 6.2 例程 下面是一个关于多重继承的虚函数表访问的例程： #include &lt;iostream&gt; using namespace std; class Base1 { public: virtual void f() { cout &lt;&lt; &quot;Base1::f&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base1::g&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base1::h&quot; &lt;&lt; endl; } }; class Base2 { public: virtual void f() { cout &lt;&lt; &quot;Base2::f&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base2::g&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base2::h&quot; &lt;&lt; endl; } }; class Base3 { public: virtual void f() { cout &lt;&lt; &quot;Base3::f&quot; &lt;&lt; endl; } virtual void g() { cout &lt;&lt; &quot;Base3::g&quot; &lt;&lt; endl; } virtual void h() { cout &lt;&lt; &quot;Base3::h&quot; &lt;&lt; endl; } }; class Derive : public Base1, public Base2, public Base3 { public: virtual void f() { cout &lt;&lt; &quot;Derive::f&quot; &lt;&lt; endl; } virtual void g1() { cout &lt;&lt; &quot;Derive::g1&quot; &lt;&lt; endl; } }; typedef void(*Fun)(void); int main() { Fun pFun = NULL; Derive d; int** pVtab = (int**)&amp;d; //Base1's vtable //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+0); pFun = (Fun)pVtab[0][0]; pFun(); //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+1); pFun = (Fun)pVtab[0][1]; pFun(); //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+2); pFun = (Fun)pVtab[0][2]; pFun(); //Derive's vtable //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+3); pFun = (Fun)pVtab[0][3]; pFun(); //The tail of the vta pFun = (Fun)pVtab[0][4]; cout&lt;&lt;pFun&lt;&lt;endl; //Base2's vtable //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0); pFun = (Fun)pVtab[1][0]; pFun(); //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1); pFun = (Fun)pVtab[1][1]; pFun(); pFun = (Fun)pVtab[1][2]; pFun(); //The tail of the vtable pFun = (Fun)pVtab[1][3]; cout&lt;&lt;pFun&lt;&lt;endl; //Base3's vtable //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0); pFun = (Fun)pVtab[2][0]; pFun(); //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1); pFun = (Fun)pVtab[2][1]; pFun(); pFun = (Fun)pVtab[2][2]; pFun(); //The tail of the vtable pFun = (Fun)pVtab[2][3]; cout&lt;&lt;pFun&lt;&lt;endl; return 0; } 7. 参考博客 https://blog.csdn.net/lyztyycode/article/details/81326699 ","link":"https://laichao2018.github.io/post/bian-cheng-yu-yan-cxu-han-shu-yu-xu-han-shu-biao/"},{"title":"[开发工具] Git Submodule的使用","content":"1. 介绍 submodule子模块，简单来讲就是Git仓库中的子仓库。 如果有一个模块是通用的，多个项目依赖这个模块；或者Github上要使用一个开源算法模块。但模块更新后，要怎么在自己的项目中保持同步更新甚至是提交呢？答案是使用Git Submodule。 2. 用法 2.1. 新增submodule git submodule add $giturl $foldername 其中＄giturl表示git仓库地址，＄foldername表示submodule的目录名，例如： git submodule add git://github.com/xx/A.git A 注：下面示例全部以 A 当做submodule所在目录 完成后，将文件变化提交即可 2.2. clone有submodule的git仓库 git clone $giturl git submodule init git submodule update 2.3. submodule A作者有更新，如何同步到我的项目？ 2.3.1 更新submodule A cd A git pull 2.3.2 回到主git仓库，查看状态，并提交 cd .. git status //输出结果有这样的内容，意思是submodule A有修改。add并提交即可 modified: A (new commits) git add . git commit -m 'update submodule' git push 2.3.3 你的同事或者协作的开发者，如何更新？ git pull git submodule update 这些操作和status的内容一开始可能很难理解，这里讲一下关于submodule的设计理念： 主git仓库中存在.gitmodules文件，它记录了submodule的基本信息。例如remote地址。 同时在某处记录了主git仓库所用的submodule的commit号。 主git仓库并不同步submodule中的所有代码，而是同步其remote地址和commit号，每个clone都是根据这两个信息自行到remote地址获取到该commit版本的内容。 所以，如果你要更新submodule必须做上面的操作步骤。而你操作完成后，你的git仓库中submodule的commit号得到更新。这样，与你协作的开发者，就可以直接git pull得到最新的submodule commit号，git submodule update获取submodule该commit的代码。 2.4. 主git仓库的开发者，同时也是submodule A的作者，如何在主git仓库修改A并同步？ 如果理解了上面说的设计理念，那么这个操作非常简单。 修改A目录中的内容 提交并同步A cd A git add . git commit git push 此时，就处于3.2的状态，按照3.2操作即可。 2.5. 几个submodule都想更到最新 简便操作: git submodule foreach git pull 这样所有submodule都更到最新了，add commit即可。 3.原文链接 https://www.jianshu.com/p/384c73fe173f ","link":"https://laichao2018.github.io/post/kai-fa-gong-ju-git-submodule-de-shi-yong/"},{"title":"关于博主","content":"👏👏👏 欢迎来到我的个人主页 ✍️✍️✍️ 这里是我的平常学习记录和学习感悟 ~~~ 博客复兴🤙🤙🤙 指南针🎶🐱‍🐉🏄‍♂️ GitHub主页🎓 个人技能🏅 🎓 熟练使用C/C++语言，熟悉OOP特性，熟悉常用数据结构，算法，设计模式 💼 熟悉点云匹配，点云过滤和点云去噪等点云算法，熟悉点云数据与影像数据多源融合算法。熟练使用PCL库，有良好的国内外论文文献查阅能力，有点云处理相关项目实践开发经验 👝 熟悉影像三维重建流程，主流的开源三维重建框架(SfM + MVS\\Bundler等)；熟悉计算机视觉和图像处理的基本算法，熟悉OpenCV图像开发库和常用图像视频协议规范 👜 熟练使用Visual Studio 开发平台，熟练掌握软件开发的调试技巧，掌握动态库编写，掌握C++/CLI等图形界面开发，熟悉Qt Creator开发环境，熟悉Qt绘图，布局和信号与槽等 ☂️ 熟悉软件说明文档与开发日志的写作，有规范命名，写注释，缩进统一的良好编程习惯 🌂 熟练掌握MySQL数据库的部署，实施，排查，故障分析处理，有相关项目经验。具备数据库设计能力，熟悉存储过程与范式 👖 熟悉Linux系统、熟悉命令行操作模式和常用命令，了解python，shell等脚本语言，有使用TensorFlow框架的图像深度学习科研经验，熟练使用Vim等工具； 👕 自学HTML/CSS/JavaScript，对jQuery、Vue等前端框架有一定的了解 👒 熟练使用集中式项目管理工具SVN与分布式管理工具Git，掌握常用管理命令，有个人GitHub网站和项目； 🤴有使用TensorFlow与Caffe(C++)的深度学习科研经历，旨在通过学习实现点云与影像的特征匹配从而达到多源数据融合 🙅‍♂具备良好的沟通能力、很强的团队意识与责任心，尽职尽责，空闲时间常常学习充电 🕴有个人GitHub项目，和基于GitHub的个人网站GitHub主页🎓，LeetCode刷题通过量约500题 开发项目✍️ 1️⃣ 地下电缆三维建模系统开发项目 📆 2018.9-2019.10 项目描述⚔️： 系统以C++为开发语言，以DirectX作为引擎的三维底层图形库，采用面向对象的方法和软件工程思想进行架构设计，将业务逻辑、数据、界面相分离的方法对软件进行模块化开发，通过建立多源空间数据模型，实现了地下电缆全要素空间数据的一体化管理、三维可视化与自动化建模。软件依次划分为数据库模块、工井模型渲染模块、三维建模模块、基础类库四个核心模块，每个模块负责不同的业务和功能，模块内高度封装，模块间相互独立，利用消息进行通信，实现了高内聚、低耦合的系统集成，代码管理使用TortoiseSVN。 项目职责🔨： 软件图形界面开发与设计，界面窗口间信息通信。 影像算法模块。以三维坐标点数据为基础，采用数字图像处理技术生成影像数据。全景影像数据三维展示，二维影像添加单位注记，影像数据显示与管理。 数据库引擎（MySQL）架构设计，存储地下电缆设施数据，数据主要分为结构化数据与非结构化数据：表与表之间主键、外键、视图的建立及多种地下电缆设备属性的增、删、查、改，更新电缆信息。 负责三维模型的导入导出管理，三维模型纹理贴图，使用AutoDesk FBX/C++SDK开发。 2️⃣ 车载激光点云处理系统 📆 2019.8-2020.6 项目描述⚔️： 车载激光点云处理系统是基于车载Lidar数据，自动提取道路中心线、特征地物，三维激光点云特征实体集等信息。特征地物点包括：桥头、隧道口、道路交叉口、道路指示牌、交通监控架、里程碑、电线杆、独立树、其他容易辨认长久存在且形状规则的地物。 项目职责🔨： 负责车载数据的车道线提取工作，采用点云生成二维影像方法，利用OpenCV库对影像目标进行阈值分割，边缘提取等操作进而转换回点云数据，进行标线提取； 使用C++/CLI搭建平台部分主界面与点云数字影像展示图形窗口的设计； 负责路灯提取；采用区域生长算法实现提取过程。 3️⃣ 北京市文物移动执法系统 📆 2018.10-2019.2 项目描述⚔️： 该项目主旨为通过利用GPS定位，对移动执法平台的三维空间点云等各种数据实现调用、查询等功能，对地面现状文物建筑及周边环境的现场调查、局部测量、拍照、取证等，辅助文物执法人员对文物建筑的安全管理工作。 项目职责🔨： 模型数据影像匀光，滤波等处理。纹理映射，模型贴图，真实化三维模型； 对点云和模型数据通过包围盒建立空间渲染结构，进行多块点云及多个模型共同渲染。 科研工作🎓 研究摘要 多源点云数据融合相对于单一数据扩展了数据应用面，有助于提高点云利用率。通过不同方法得到的三维点云数据由于获取途径与设备误差的影响，不同数据之间往往存在着尺度不一致，初始位置相差大，噪声较大产生较大的特征误匹配等问题。本文使用三维重建点云对激光点云进行修复，提出一种适用不同尺度点云数据的全局优化的自动点云融合方法，融合结果与点云初始位置无关，并对噪声较大与特征错配率较高数据具有稳定性。通过从点云数据中提取特征描述信息进行匹配，并通过误匹配去除与几何相似筛选，将确定的点云对应关系代入含尺度变量的目标函数并逐一优化各个分量，计算结果作为初始值代入Scale-ICP中进行精确融合。实验表明本文方法在处理不同尺度含外点的实测数据时具有良好的融合结果。 研究成果 融合效果 融合精度 获奖与证书✨ ⭐️ 2015年获得大学英语四级证书 ⭐️ 2017年获得大学英语六级证书 ⭐️ 2016福建省测绘技能大赛二等奖 ⭐️ 2018年度研究生学业奖学金 ⭐️ 2019年度研究生学业奖学金 ","link":"https://laichao2018.github.io/post/guan-yu-bo-zhu/"},{"title":"Hello Gridea","content":"👏 欢迎使用 Gridea ！ ✍️ Gridea 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ... Github Gridea 主页 示例网站 特性👇 📝 你可以使用最酷的 Markdown 语法，进行快速创作 🌉 你可以给文章配上精美的封面图和在文章任意位置插入图片 🏷️ 你可以对文章进行标签分组 📋 你可以自定义菜单，甚至可以创建外部链接菜单 💻 你可以在 Windows，MacOS 或 Linux 设备上使用此客户端 🌎 你可以使用 𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌 或 Coding Pages 向世界展示，未来将支持更多平台 💬 你可以进行简单的配置，接入 Gitalk 或 DisqusJS 评论系统 🇬🇧 你可以使用中文简体或英语 🌁 你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力 🖥 你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步 🌱 当然 Gridea 还很年轻，有很多不足，但请相信，它会不停向前 🏃 未来，它一定会成为你离不开的伙伴 尽情发挥你的才华吧！ 😘 Enjoy~ ","link":"https://laichao2018.github.io/post/hello-gridea/"}]}