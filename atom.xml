<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://laichao2018.github.io</id>
    <title>赖超的个人网站</title>
    <updated>2020-11-06T07:04:33.703Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://laichao2018.github.io"/>
    <link rel="self" href="https://laichao2018.github.io/atom.xml"/>
    <subtitle>&lt;b&gt;记录学习点滴，欢迎浏览</subtitle>
    <logo>https://laichao2018.github.io/images/avatar.png</logo>
    <icon>https://laichao2018.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, 赖超的个人网站</rights>
    <entry>
        <title type="html"><![CDATA[[编程语言]C++虚函数与虚函数表]]></title>
        <id>https://laichao2018.github.io/post/bian-cheng-yu-yan-cxu-han-shu-yu-xu-han-shu-biao/</id>
        <link href="https://laichao2018.github.io/post/bian-cheng-yu-yan-cxu-han-shu-yu-xu-han-shu-biao/">
        </link>
        <updated>2020-11-06T02:04:19.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-前言">1. 前言</h2>
<p>+ C++中的虚函数的作用主要是****实现了多态*<em><strong>的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到</strong></em>*运行时决议****。</p>
<h2 id="2-虚函数表">2. 虚函数表</h2>
<p>对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。</p>
<p>C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能——如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。</p>
<p>虚表指针的名字也会被编译器更改，所以在多继承的情况下，类的内部可能存在多个虚表指针。通过不同的名字被编译器标识。</p>
<p>假设我们有这样的一个类：</p>
<pre><code class="language-cpp">class Base {
​    public:
​      virtual void f() { cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; }
​      virtual void g() { cout &lt;&lt; &quot;Base::g&quot; &lt;&lt; endl; }
​      virtual void h() { cout &lt;&lt; &quot;Base::h&quot; &lt;&lt; endl; }
};
</code></pre>
<p>按照上面的说法，可以通过Base的实例来得到虚函数表。 下面是实际例程：</p>
<pre><code class="language-cpp">typedef void(*Fun)(void);
Base b;
Fun pFun = NULL;
cout &lt;&lt; &quot;虚函数表地址：&quot; &lt;&lt; (int*)(&amp;b) &lt;&lt; endl;
cout &lt;&lt; &quot;虚函数表 — 第一个函数地址：&quot; &lt;&lt; (int*)*(int*)(&amp;b) &lt;&lt; endl;
// Invoke the first virtual function
pFun = (Fun)*((int*)*(int*)(&amp;b));
pFun();
</code></pre>
<p>实际运行经果如下：(Windows XP+VS2003, Linux 2.6.22 + GCC 4.1.3)</p>
<blockquote>
<p><strong>虚函数表地址：0012FED4</strong><br>
<strong>虚函数表 — 第一个函数地址：0044F148</strong><br>
<strong>Base::f</strong></p>
</blockquote>
<p>通过这个示例，可以看到，我们可以通过强行把&amp;b转成int <em>，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int</em> 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下：</p>
<pre><code class="language-cpp">(Fun)*((int*)*(int*)(&amp;b)+0); *// Base::f()*
(Fun)*((int*)*(int*)(&amp;b)+1); *// Base::g()*
(Fun)*((int*)*(int*)(&amp;b)+2); *// Base::h()*
</code></pre>
<p>画个图解释一下。如下所示:</p>
<figure data-type="image" tabindex="1"><img src="https://laichao2018.github.io/post-images/1604645798579.jpg" alt="" loading="lazy"></figure>
<p>注意：在上面这个图中，在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“<em>/0</em>”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在<em>WinXP+VS2003</em>下，这个值是<em>NULL</em>。而在<em>Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3</em>下，这个值是如果<em>1</em>，表示还有下一个虚函数表，如果值是<em>0</em>，表示是最后一个虚函数表。</p>
<p>下面，将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。</p>
<h2 id="3-继承与虚函数表">3. 继承与虚函数表</h2>
<h4 id="31-一般继承无虚函数覆盖">3.1 一般继承（无虚函数覆盖）</h4>
<p>下面，再来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：<br>
<img src="https://laichao2018.github.io/post-images/1604645833272.jpg" alt="" loading="lazy"><br>
请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示<br>
对于实例：Derive d; 的虚函数表如下：<br>
<img src="https://laichao2018.github.io/post-images/1604645838066.JPG" alt="" loading="lazy"><br>
我们可以看到下面几点：</p>
<ol>
<li>虚函数按照其声明顺序放于表中。</li>
<li>父类的虚函数在子类的虚函数前面。</li>
</ol>
<h4 id="32-一般继承有虚函数覆盖">3.2 一般继承（有虚函数覆盖）</h4>
<p>覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，有下面这样的一个继承关系。</p>
<figure data-type="image" tabindex="2"><img src="https://laichao2018.github.io/post-images/1604645844186.jpg" alt="" loading="lazy"></figure>
<p>为了看到被继承过后的效果，在这个类的设计中，只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：<br>
<img src="https://laichao2018.github.io/post-images/1604645851133.JPG" alt="" loading="lazy"></p>
<p>我们从表中可以看到下面几点，</p>
<ol>
<li>覆盖的f()函数被放到了虚表中原来父类虚函数的位置。</li>
<li>没有被覆盖的函数依旧。<br>
这样，我们就可以看到对于下面这样的程序，</li>
</ol>
<pre><code class="language-cpp">Base *b = new Derive();
b-&gt;f();
</code></pre>
<p>由b所指的内存中的虚函数表的<font color=red>f()</font>的位置已经被<font color=red>Derive::f()</font>函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。</p>
<h4 id="33-多重继承无虚函数覆盖">3.3 多重继承（无虚函数覆盖）</h4>
<p>下面，再看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数：</p>
<figure data-type="image" tabindex="3"><img src="https://laichao2018.github.io/post-images/1604645857538.png" alt="" loading="lazy"></figure>
<p>对于子类实例中的虚函数表，是下面这个样子：</p>
<figure data-type="image" tabindex="4"><img src="https://laichao2018.github.io/post-images/1604645862196.png" alt="" loading="lazy"></figure>
<p>我们可以看到：</p>
<ol>
<li>每个父类都有自己的虚表。</li>
<li>子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）<br>
这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。</li>
</ol>
<h4 id="34-多重继承有虚函数覆盖">3.4 多重继承（有虚函数覆盖）</h4>
<p>下面再来看看，如果发生虚函数覆盖的情况。下图中，我们在子类中覆盖了父类的f()函数。</p>
<figure data-type="image" tabindex="5"><img src="https://laichao2018.github.io/post-images/1604645869560.png" alt="" loading="lazy"></figure>
<p>下面是对于子类实例中的虚函数表的图：</p>
<figure data-type="image" tabindex="6"><img src="https://laichao2018.github.io/post-images/1604645874974.jpg" alt="" loading="lazy"></figure>
<p>可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：</p>
<pre><code class="language-cpp">  Derive d;
        Base1 *b1 = &amp;d;
        Base2 *b2 = &amp;d;
        Base3 *b3 = &amp;d;
        b1-&gt;f();     //Derive::f()
        b2-&gt;f();     //Derive::f()
        b3-&gt;f();     //Derive::f() 
        b1-&gt;g();    //Base1::g()
        b2-&gt;g();    //Base2::g()
        b3-&gt;g();    //Base3::g()
</code></pre>
<h2 id="4-安全性">4. 安全性</h2>
<p><strong>水可载舟，亦可覆舟。</strong></p>
<h4 id="41-通过父类型的指针访问子类自己的虚函数">4.1 通过父类型的指针访问子类自己的虚函数</h4>
<p>子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数：</p>
<pre><code class="language-cpp">Base1 *b1 = new Derive();
b1-&gt;f1();  //编译出错
</code></pre>
<p>任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点）</p>
<h4 id="42-访问non-public的虚函数">4.2 访问non-public的虚函数</h4>
<p>另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。如：</p>
<pre><code class="language-cpp">class Base {
    private:
            virtual void f() { cout &lt;&lt; &quot;Base::f&quot; &lt;&lt; endl; 
}; 

class Derive : public Base{

};

typedef void(*Fun)(void);

void main() {
    Derive d;
    Fun  pFun = (Fun)*((int*)*(int*)(&amp;d)+0);
    pFun();

}
</code></pre>
<h2 id="5-结束语">5. 结束语</h2>
<p>C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。</p>
<h2 id="6-附录">6. 附录</h2>
<h4 id="61-vc中查看虚函数表">6.1 VC中查看虚函数表</h4>
<p>以在VC的IDE环境中的Debug状态下展开类的实例就可以看到虚函数表了（并不是很完整的）<br>
<img src="https://laichao2018.github.io/post-images/1604645883090.JPG" alt="" loading="lazy"></p>
<h4 id="62-例程">6.2 例程</h4>
<p>下面是一个关于多重继承的虚函数表访问的例程：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Base1 {
    public:
            virtual void f() { cout &lt;&lt; &quot;Base1::f&quot; &lt;&lt; endl; }
            virtual void g() { cout &lt;&lt; &quot;Base1::g&quot; &lt;&lt; endl; }
            virtual void h() { cout &lt;&lt; &quot;Base1::h&quot; &lt;&lt; endl; }
};

class Base2 {
    public:
            virtual void f() { cout &lt;&lt; &quot;Base2::f&quot; &lt;&lt; endl; }
            virtual void g() { cout &lt;&lt; &quot;Base2::g&quot; &lt;&lt; endl; }
            virtual void h() { cout &lt;&lt; &quot;Base2::h&quot; &lt;&lt; endl; }
}; 

class Base3 {
    public:
            virtual void f() { cout &lt;&lt; &quot;Base3::f&quot; &lt;&lt; endl; }
            virtual void g() { cout &lt;&lt; &quot;Base3::g&quot; &lt;&lt; endl; }
            virtual void h() { cout &lt;&lt; &quot;Base3::h&quot; &lt;&lt; endl; }
};

class Derive : public Base1, public Base2, public Base3 {
    public:
            virtual void f() { cout &lt;&lt; &quot;Derive::f&quot; &lt;&lt; endl; }
            virtual void g1() { cout &lt;&lt; &quot;Derive::g1&quot; &lt;&lt; endl; }
};

typedef void(*Fun)(void);

int main() {
            Fun pFun = NULL;
            Derive d;
            int** pVtab = (int**)&amp;d;
            //Base1's vtable
            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+0);
            pFun = (Fun)pVtab[0][0];
            pFun();
            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+1);
            pFun = (Fun)pVtab[0][1];
            pFun();
            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+2);
            pFun = (Fun)pVtab[0][2];
            pFun();
            //Derive's vtable
            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+0)+3);
            pFun = (Fun)pVtab[0][3];
            pFun();
            //The tail of the vta
            pFun = (Fun)pVtab[0][4];
            cout&lt;&lt;pFun&lt;&lt;endl;
           
            //Base2's vtable
            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0);
            pFun = (Fun)pVtab[1][0];
            pFun();
            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1);
            pFun = (Fun)pVtab[1][1];
            pFun();
            pFun = (Fun)pVtab[1][2];
            pFun();
           
            //The tail of the vtable
            pFun = (Fun)pVtab[1][3];
            cout&lt;&lt;pFun&lt;&lt;endl;
           
            //Base3's vtable
            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+0);
            pFun = (Fun)pVtab[2][0];
            pFun();
            //pFun = (Fun)*((int*)*(int*)((int*)&amp;d+1)+1);

            pFun = (Fun)pVtab[2][1];
            pFun();
            pFun = (Fun)pVtab[2][2];
            pFun();

            //The tail of the vtable
            pFun = (Fun)pVtab[2][3];
            cout&lt;&lt;pFun&lt;&lt;endl;
            return 0;
}
</code></pre>
<h2 id="7-参考博客">7. 参考博客</h2>
<ul>
<li><a href="https://blog.csdn.net/lyztyycode/article/details/81326699">https://blog.csdn.net/lyztyycode/article/details/81326699</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[开发工具] Git Submodule的使用]]></title>
        <id>https://laichao2018.github.io/post/kai-fa-gong-ju-git-submodule-de-shi-yong/</id>
        <link href="https://laichao2018.github.io/post/kai-fa-gong-ju-git-submodule-de-shi-yong/">
        </link>
        <updated>2020-11-05T13:19:17.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1-介绍">1. 介绍</h2>
<ul>
<li>submodule子模块，简单来讲就是Git仓库中的子仓库。</li>
<li>如果有一个模块是通用的，多个项目依赖这个模块；或者Github上要使用一个开源算法模块。但模块更新后，要怎么在自己的项目中保持同步更新甚至是提交呢？答案是使用Git Submodule。</li>
</ul>
<h2 id="2-用法">2. 用法</h2>
<h3 id="21-新增submodule"><strong>2.1. 新增submodule</strong></h3>
<pre><code class="language-cpp">git submodule add $giturl $foldername
</code></pre>
<p>其中<font color=red>＄giturl</font>表示git仓库地址，<font color=red>＄foldername</font>表示submodule的目录名，例如：</p>
<pre><code>git submodule add git://github.com/xx/A.git A
</code></pre>
<blockquote>
<p>注：下面示例全部以 A 当做submodule所在目录</p>
</blockquote>
<p>完成后，将文件变化提交即可</p>
<h3 id="22-clone有submodule的git仓库"><strong>2.2. clone有submodule的git仓库</strong></h3>
<pre><code>git clone $giturl
git submodule init
git submodule update
</code></pre>
<h3 id="23-submodule-a作者有更新如何同步到我的项目"><strong>2.3. submodule A作者有更新，如何同步到我的项目？</strong></h3>
<p><strong>2.3.1 更新submodule A</strong></p>
<pre><code class="language-cpp"> cd A
 git pull
</code></pre>
<p><strong>2.3.2 回到主git仓库，查看状态，并提交</strong></p>
<pre><code class="language-cpp"> cd ..
 git status

 //输出结果有这样的内容，意思是submodule A有修改。add并提交即可
 modified:   A (new commits)

 git add .
 git commit -m 'update submodule'
 git push
</code></pre>
<p><strong>2.3.3 你的同事或者协作的开发者，如何更新？</strong></p>
<pre><code class="language-cpp"> git pull
 git submodule update
</code></pre>
<p>这些操作和status的内容一开始可能很难理解，这里讲一下关于submodule的设计理念：</p>
<ul>
<li>主git仓库中存在<font color=red>.gitmodules</font>文件，它记录了submodule的基本信息。例如remote地址。</li>
<li>同时在某处记录了主git仓库所用的submodule的commit号。</li>
<li>主git仓库并不同步submodule中的所有代码，而是同步其remote地址和commit号，每个clone都是根据这两个信息自行到remote地址获取到该commit版本的内容。</li>
</ul>
<p>所以，如果你要更新submodule必须做上面的操作步骤。而你操作完成后，你的git仓库中submodule的commit号得到更新。这样，与你协作的开发者，就可以直接<font color=red>git pull</font>得到最新的submodule commit号，<font color=red>git submodule update</font>获取submodule该commit的代码。</p>
<h3 id="24-主git仓库的开发者同时也是submodule-a的作者如何在主git仓库修改a并同步"><strong>2.4. 主git仓库的开发者，同时也是submodule A的作者，如何在主git仓库修改A并同步？</strong></h3>
<p>如果理解了上面说的设计理念，那么这个操作非常简单。</p>
<ol>
<li>修改A目录中的内容</li>
<li>提交并同步A</li>
</ol>
<pre><code class="language-cpp"> cd A
 git add .
 git commit
 git push
</code></pre>
<ol start="3">
<li>此时，就处于3.2的状态，按照3.2操作即可。</li>
</ol>
<h3 id="25-几个submodule都想更到最新"><strong>2.5. 几个submodule都想更到最新</strong></h3>
<p>简便操作:</p>
<pre><code class="language-cpp">git submodule foreach git pull
</code></pre>
<p>这样所有submodule都更到最新了，add commit即可。</p>
<h2 id="3原文链接">3.原文链接</h2>
<ul>
<li><a href="https://www.jianshu.com/p/384c73fe173f">https://www.jianshu.com/p/384c73fe173f</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于博主]]></title>
        <id>https://laichao2018.github.io/post/guan-yu-bo-zhu/</id>
        <link href="https://laichao2018.github.io/post/guan-yu-bo-zhu/">
        </link>
        <updated>2020-08-24T07:37:49.000Z</updated>
        <content type="html"><![CDATA[<p><strong>👏👏👏欢迎来到我的个人主页</strong></p>
<p>✍️✍️✍️ <strong>这里是我的平常学习记录和学习感悟</strong> ~~~ <strong>博客复兴🤙🤙🤙</strong></p>
<h4 id="指南针️">指南针🎶🐱‍🐉🏄‍♂️</h4>
<p><a href="https://github.com/LAICHAO2018">GitHub主页🎓</a></p>
<h4 id="个人技能">个人技能😘👨‍🎓🥝</h4>
<blockquote>
<ul>
<li>🎓计算机相关专业(地理信息工程) 相关硕士/学士，4年计算机编程学习经验，3年相关开发经验，个人在校参与项目工作编写代码累积量约1万行</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>💼精通C/C++，基础扎实，熟悉数据库编程，有底层开发开发经验，熟练掌握面向对象思想、STL等C++特性</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>👝技术全面，对QT、C# .Net、MFC 、Java、Python等均有一定程度的了解与接触，编写过相关代码</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>👜熟悉CMake/Makefile等常用C++构建工具，能够编写项目CMake文档</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>☂️熟悉软件说明文档与开发日志的写作，有规范命名，写注释，缩进统一的良好编程习惯</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>🌂熟练掌握MySQL数据库的部署，实施，排查，故障分析处理，有相关项目经验</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>👖熟悉影像三维重建的构建过程，对主流SfM/MVS等PipeLine有较深入的理解，有较深刻的理论基础与实际实现能力，阅读过底层开源代码</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>👕自学HTML/CSS/JavaScript，对jQuery、Vue等前端框架有一定的了解</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>👒Linux爱好者，使用Ubuntu 18.04作为PC系统，熟练管理各种增强插件，Vimer，熟练运用常用命令并共享了相关配置文件</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>🕴有个人GitHub项目，和基于GitHub的个人网站<a href="https://github.com/LAICHAO2018">GitHub主页🎓</a>，LeetCode刷题通过量约500题</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>🤴有使用TensorFlow与Caffe(C++)的深度学习科研经历，旨在通过学习实现点云与影像的特征匹配从而达到多源数据融合</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>🙅‍♂具备良好的沟通能力、很强的团队意识与责任心，尽职尽责，空闲时间常常学习充电</li>
</ul>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://laichao2018.github.io/post/hello-gridea/</id>
        <link href="https://laichao2018.github.io/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>